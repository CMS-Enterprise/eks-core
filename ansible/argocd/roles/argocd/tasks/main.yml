---
#Ensure the Kuberentes python package is installed
- name: Install k8s python package
  ansible.builtin.pip:
    name: kubernetes
  delegate_to: localhost

#Create Namespace
- name: ARGOCD NAMESPACE | Create dedicated namespace
  kubernetes.core.k8s:
    api_version: v1
    kind: Namespace
    name: "{{ argocd_k8s_namespace }}"
    state: "{{ argocd_install }}"
  run_once: yes

#Deploy ArgoCD Manifests
- name: ARGOCD INSTALL | Deploy Kubernetes objects
  run_once: yes
  block:
    - name: Fetch ArgoCD server pod name
      shell: kubectl get po -n {{ argocd_k8s_namespace }} -l app.kubernetes.io/name=argocd-server -o jsonpath={.items[*].metadata.name}
      register: argocd_k8s_pod_name
      ignore_errors: yes

    - name: Set ArgoCD installation status
      set_fact:
        argocd_installed: "{{ argocd_k8s_pod_name.stdout != '' }}"

    - name: ARGOCD KUBERNETES | Download Kubernetes yaml file definition
      get_url:
        url: https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        dest: /tmp/argocd_install.yaml
        validate_certs: no
      when: not argocd_installed

    - name: ARGOCD KUBERNETES | Manage Kubernetes objects
      kubernetes.core.k8s:
        namespace: "{{ argocd_k8s_namespace }}"
        src: /tmp/argocd_install.yaml
        state: "{{ argocd_install }}"
      when: not argocd_installed
  always:
    - name: ARGOCD KUBERNETES | Clean installation
      file:
        path: /tmp/argocd_install.yaml
        state: absent
      when: not argocd_installed

#Check ArgoCD CLI
- name: Check if ArgoCD CLI is installed on OS
    include_tasks: cli.yml

#Setup Service, Cert, and DNS
- name: ARGOCD SERVICE | Set facts
  run_once: yes
  block:
    - name: ARGOCD SERVICE | get ACM certificate arn
      shell: aws acm list-certificates --region {{ aws_region }} --query "CertificateSummaryList[?DomainName=='{{ domain }}'].CertificateArn | [0]" --output text --no-cli-pager
      register: acm_arn

    - name: ARGOCD SERVICE | Create GRPC service
      kubernetes.core.k8s:
        state: present
        definition: 
          apiVersion: v1
          kind: Service
          metadata:
            annotations:
              alb.ingress.kubernetes.io/backend-protocol-version: GRPC 
            labels:
              app: argogrpc
            name: argogrpc
            namespace: argocd
          spec:
            ports:
            - name: "443"
              port: 443
              protocol: TCP
              targetPort: 8080
            selector:
              app.kubernetes.io/name: argocd-server
            sessionAffinity: None
            type: NodePort

    - name: ARGOCD SERVICE | Patch UI service
      kubernetes.core.k8s:
        state: patched
        kind: Service
        namespace: "{{ argocd_k8s_namespace }}"
        name: argocd-server
        merge_type: strategic-merge
        definition: 
          spec:
            type: NodePort        

    - name: ARGOCD SERVICE | Apply ArgoCD Ingress
      kubernetes.core.k8s:
        state: present
        definition: 
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: argocd-server-ingress
            namespace: argocd
            annotations:
              alb.ingress.kubernetes.io/scheme: "internal"
              alb.ingress.kubernetes.io/load-balancer-name: "argocd-ingress-alb"
              alb.ingress.kubernetes.io/certificate-arn: "{{ acm_arn.stdout }}"
              alb.ingress.kubernetes.io/ssl-policy: "ELBSecurityPolicy-TLS13-1-2-2021-06"
              alb.ingress.kubernetes.io/security-groups: "sg-0ca5b90ade2d2fe89"
              alb.ingress.kubernetes.io/backend-protocol: HTTPS
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS": 443}]'
              alb.ingress.kubernetes.io/ssl-redirect: '443'
              alb.ingress.kubernetes.io/ip-address-type: ipv4
              alb.ingress.kubernetes.io/target-type: instance
              alb.ingress.kubernetes.io/conditions.argogrpc: |
                [{"field":"http-header","httpHeaderConfig":{"httpHeaderName": "Content-Type", "values":["application/grpc"]}}]
          spec:
            ingressClassName: alb
            rules:
            - host: "argocd-{{ cluster_name }}.{{ domain }}"
              http:
                paths:
                - path: /*
                  pathType: ImplementationSpecific  
                  backend:
                    service:
                      name: argogrpc
                      port:
                        number: 443
                - path: /*
                  pathType: ImplementationSpecific
                  backend:
                    service:
                      name: argocd-server
                      port:
                        number: 443        

    - name: ARGOCD SERVICE | Wait for 5 seconds for ALB to be ensured
      pause:
        seconds: 5

    - name: ARGOCD SERVICE | Retrieve the ALB CNAME from the Ingress status
      shell: kubectl get ingress argocd-server-ingress -n {{ argocd_k8s_namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
      register: alb_cname

    - name: ARGOCD SERVICE | Create a CNAME record in Route 53
      amazon.aws.route53:
        state: present
        zone: "{{ domain }}"
        record: "argocd-{{ cluster_name }}.{{ domain }}"
        type: CNAME
        value: "{{ alb_cname.stdout }}"
        ttl: 300
        private_zone: true
        overwrite: true

#Change ADMIN user Password
- name: ARGOCD INSTALL | Manage admin user
  run_once: yes
  block:
    - name: ARGOCD USERS | Fetch ArgoCD server password
      shell: kubectl get secret argocd-initial-admin-secret -n {{ argocd_k8s_namespace }} -o jsonpath="{.data.password}" | base64 --decode
      register: argocd_k8s_init_password

    - name: ARGOCD USERS | Set ArgoCD password fact
      set_fact:
        argocd_current_admin_password: "{{ argocd_k8s_init_password.stdout }}"

    - name: ARGOCD USERS | Log into ArgoCD with CLI
      shell: argocd login argocd-{{ cluster_name }}.{{ domain }} --username admin --password {{ argocd_current_admin_password }} --grpc-web

    - name: ARGOCD USERS | Generate a temporary password
      set_fact:
        generated_password: "{{ lookup('ansible.builtin.password', '/tmp/passwordfile', chars=['ascii_letters', 'digits', 'punctuation']) }}"

    - name: ARGOCD USERS | Manage ArgoCD Admin password
      shell: argocd account update-password --current-password {{ argocd_current_admin_password }} --new-password {{ generated_password }} --insecure

    - name: ARGOCD USERS | Store the new ArgoCD Admin password in AWS Secrets Manager
      shell: aws secretsmanager update-secret --secret-id {{ cluster_name }}-argocd-admin-password --secret-string {{ generated_password }}
      environment:
        AWS_DEFAULT_REGION: "{{ aws_region }}" 
  when: not argocd_installed             

#Install Master App
- name: Install Master App
    include_tasks: applications.yml

#Uninstall ArgoCD
- name: ARGOCD UNINSTALL | Delete Kubernetes objects
  kubernetes.core.k8s:
    namespace: "{{ argocd_k8s_namespace }}"
    src: /tmp/argocd_install.yaml
    state: "{{ argocd_install }}"
  when: argocd_install == "absent"   
  

- name: ARGOCD UNINSTALL | Delete namespace
  kubernetes.core.k8s:
    api_version: v1
    kind: Namespace
    name: "{{ argocd_k8s_namespace }}"
    state: "{{ argocd_install }}"
  when: argocd_install == "absent"

- name: ARGOCD UNINSTALL | Delete command line tool
  file:
    path: "{{ argocd_cli_path }}"
    state: absent
  when: argocd_install == "absent"  
